package ProteomeXchange::Tweet;

use strict;
use warnings;

use lib "/net/dblocal/wwwspecial/proteomecentral/extern/perl/lib/perl5/site_perl/5.14.2";

use Net::Twitter::Lite::WithAPIv1_1;
use Scalar::Util 'blessed';
use Storable;

use ProteomeXchange::Configuration qw( %CONFIG );

my $DEBUG = 0;

###############################################################################
# Constructor
###############################################################################
sub new {
    my $this = shift;
    my $class = ref($this) || $this;
    my $self = {};
    bless $self, $class;

    #### Initialize class variables the first time the class is used
    # none

    #### Process constructor argument class variables
    my %args = @_;
    $self->setMassType($args{massType}) if ($args{massType});

    #### Process constructor argument object variables
    # none

    return($self);
}


###############################################################################
# prepareTweetContent
###############################################################################
sub prepareTweetContent {
  my $METHOD = 'prepareTweetContent';
  my $self = shift || die ("self not passed");
  my %args = @_;

  #### Process parameters
  my $datasetTitle = $args{datasetTitle} || '??';
  my $PXPartner = $args{PXPartner} || '??';
  my $datasetIdentifier = $args{datasetIdentifier} ||'??';
  my $datasetSubmitter = $args{datasetSubmitter};
  my $datasetLabHead = $args{datasetLabHead};
  my $datasetSpeciesString = $args{datasetSpeciesString};
  my $datasetStatus = $args{datasetStatus} || '??';

  #### Prepare response
  my %result;
  $result{status} = 'ERROR';
  $result{message} = 'Unknown failure';

  #### Ensure there is something to search with
  unless ($datasetTitle) {
    $result{message} = 'Empty title string. Cannot create a tweet without a title.';
    return \%result;
  }

  my $fullURL = "https://proteomecentral.proteomexchange.org/dataset/$datasetIdentifier";

  my $sourceString = '??';
  if ($datasetLabHead && (length($datasetLabHead) < 30)) {
    $sourceString = "from the $datasetLabHead lab";
  } elsif ($datasetSubmitter && (length($datasetSubmitter) < 30)) {
    $sourceString = "by $datasetSubmitter";
  } else {
     $sourceString = "(malformed source)";
  }

  my $speciesString = $datasetSpeciesString || '';
  if ($datasetSpeciesString =~ /scientific name: (.+?);/) {
    $speciesString = $1;
  }
  $speciesString = "Human" if ($speciesString =~ /Homo sapiens/i);
  $speciesString = "Mouse" if ($speciesString =~ /Mus musculus/i);
  $speciesString =  " ($speciesString)" if ($speciesString);

  my $announcementType = ucfirst($datasetStatus);

  #### For testing, force to 23 characters, which all URLs are remapped to by Twitter
  #$fullURL = "https://t.co/34567890123";

  #### Create the tweet string
  my $tweetString = "$announcementType $datasetIdentifier $sourceString via $PXPartner: $speciesString ";
  my $len = length($tweetString);
  my $amountLeft = 140 - 26 - $len;

  #### Something is wrong, but just hack it off so we can get some of the title there
  if ($amountLeft < 30) {
    $tweetString = substr($tweetString,0,140-26-30).".. ";
    $len = length($tweetString);
    $amountLeft = 140 - 26 - $len;
  }

  my $truncatedTitle = $datasetTitle;
  $truncatedTitle = substr($datasetTitle,0,$amountLeft-3).'...' if (length($datasetTitle) > $amountLeft);
  $tweetString .= "$truncatedTitle - $fullURL";

  #### Store the result
  $self->{tweetString} = $tweetString;
  $self->{tweetLength} = length($tweetString);

  $result{status} = 'SUCCESS';
  $result{message} = 'Tweet string created successfully';

  return(\%result);
}


###############################################################################
# getTweet
###############################################################################
sub getTweet {
  my $METHOD = 'getTweet';
  my $self = shift || die ("self not passed");
  my %args = @_;

  #### Process parameters
  # none

  #### Prepare response
  my $result;

  #### If there is a tweet string, show it
  if ($self->{tweetString}) {
    $result = "$self->{tweetString}  (length=$self->{tweetLength})";
  } else {
    $result = "ERROR: No tweet string";
  }

  return($result);
}


###############################################################################
# getTweetAsHTML
###############################################################################
sub getTweetAsHTML {
  my $METHOD = 'getTweetAsHTML';
  my $self = shift || die ("self not passed");
  my %args = @_;

  #### Process parameters
  # none

  #### Prepare response
  my $result;

  #### If there is a tweet string, show it
  if ($self->{tweetString}) {
    $result = "Autogenerated tweet would be:<BR>$self->{tweetString}<BR>\n";
  } else {
    $result = "ERROR: No tweet string<BR>\n";
  }

  return($result);
}


###############################################################################
# sendTweet
###############################################################################
sub sendTweet {
  my $METHOD = 'sendTweet';
  my $self = shift || die ("self not passed");
  my %args = @_;

  #### Process parameters
  my $tweetString = $args{tweetString};
  if ($tweetString) {
    $self->{tweetString} = $tweetString;
  }

  #### Prepare response
  my $result = "ERROR";

  #### If there's no tweet string, then error out
  unless ($self->{tweetString}) {
    $result = "ERROR: Tweet string is null. Maybe need to prepareTweetContent() first?";
    return $result;
  }

  my $tokensFile = $CONFIG{twitterTokens};

  #### Get the keys for access to my account via this app
  my $access_tokens = eval { retrieve($tokensFile) } || [];
  unless ( @$access_tokens ) {
    $result = "ERROR: Unable to access the user access tokens";
    return $result;
  }

  my $nt = Net::Twitter::Lite::WithAPIv1_1->new(
      consumer_key        => $access_tokens->[4],
      consumer_secret     => $access_tokens->[5],
      access_token        => $access_tokens->[0],
      access_token_secret => $access_tokens->[1],
      ssl                 => 1,
  );

  #### Tweet diagnostics
  if ( 0 ) {
    print "tweetString:===$self->{tweetString}===\n";
    print "Length=".length($self->{tweetString})."\n";
    my $beforeHttp = substr($self->{tweetString},0,index($self->{tweetString},"http"));
    print "beforeHttp:===$beforeHttp===\n";
    print "Length=".length($beforeHttp)."\n";
  }


  #### Send the tweet
  my $response = eval { $nt->update($self->{tweetString}) };

  if ( $@ ) {
    $result = "ERROR: $@";
  } else {
    $result = "SUCCESS";
  }

  return $result;

  ##################################
  #### The below is just for testing

  #### Try to find the most recent tweet
  eval {
      my $statuses = $nt->home_timeline({ count => 1 });
      for my $status ( @$statuses ) {
          print "$status->{created_at} <$status->{user}{screen_name}> $status->{text}\n";
      }
  };

  if ( my $err = $@ ) {
      die $@ unless blessed $err && $err->isa('Net::Twitter::Lite::Error');

      warn "HTTP Response Code: ", $err->code, "\n",
           "HTTP Message......: ", $err->message, "\n",
           "Twitter error.....: ", $err->error, "\n";
  }

  return($result);
}


###############################################################################
# listRecentTweets
###############################################################################
sub listRecentTweets {
  my $METHOD = 'listRecentTweets';
  my $self = shift || die ("self not passed");
  my %args = @_;

  #### Process parameters
  my $count = $args{count} || 5;

  #### Prepare response
  my $result;

  my $tokensFile = $CONFIG{twitterTokens};

  #### Get the keys for access to my account via this app
  my $access_tokens = eval { retrieve($tokensFile) } || [];
  unless ( @$access_tokens ) {
    die("ERROR: Unable to access the user access tokens");
  }

  my $nt = Net::Twitter::Lite::WithAPIv1_1->new(
      consumer_key        => $access_tokens->[4],
      consumer_secret     => $access_tokens->[5],
      access_token        => $access_tokens->[0],
      access_token_secret => $access_tokens->[1],
      ssl                 => 1,
  );

  #### Try to fetch the most recent tweets
  eval {
      my $statuses = $nt->home_timeline({ count => $count });
      for my $status ( @$statuses ) {
          print "$status->{created_at} <$status->{user}{screen_name}> $status->{text}\n";
      }
  };

  #### If there was an error, show it
  if ( my $err = $@ ) {
      die $@ unless blessed $err && $err->isa('Net::Twitter::Lite::Error');

      warn "HTTP Response Code: ", $err->code, "\n",
           "HTTP Message......: ", $err->message, "\n",
           "Twitter error.....: ", $err->error, "\n";
  }

  return($result);
}



###############################################################################
1;
